---
title: "STATS 506 HW 6"
author: "Calder Moore"
format: pdf
editor: visual
---

## Problem 1 - Rcpp

```{r}
library(Rcpp)

cppFunction("
            double C_moment(NumericVector v, int k) {
              double sum = 0;
              for (int i = 0; i < v.length(); ++i){
                sum += v[i];
              }
              
              double mu = 0.0;
              mu = (sum/v.length());
              
              double acc = 0.0;
              for (int i = 0; i < v.length(); i++) {
                acc += pow(v[i] - mu, k);
              }
          
              return acc / v.length();
            
            }")

C_moment(v = c(1,0,2,3,4.5,6.7,9,1.2), k = 3)

e1071::moment(x = c(1,0,2,3,4.5,6.7,9,1.2), order = 3, center = TRUE)
```

They match when the $\texttt{center}$ argument in $\texttt{e1071::moment}$ is set to $\texttt{TRUE}$, they won't match otherwise since the $\texttt{C_moment}$ function is calculating moments relative to the mean ($\texttt{mu}$ in the function) and so we need the other function to also be calculating centered moments.

##Problem 2 - Expanding on waldCI

### a)

Read in waldCI using $\texttt{source()}$.

```{r}
source("C:/Users/moore/Desktop/School/Master/STATS 506/STATS-506-HW-5/hw5_code.R")
```

```{r}
library(parallel)

setClass(
  "bootstrapWaldCI",
  contains = "waldCI",
  slots = c(
    data = "ANY",
    reps = "numeric",
    fun = "function",
    compute = "character",
    boot_vals = "numeric"
  )
)

#function
boot <- function(fun, data, reps, compute){

  n <- nrow(data)

  one_boot <- function(i){
    idx <- sample(seq_len(n), n, replace = TRUE)
    fun(data[idx, , drop = FALSE])
  }
  #no parallel
  if (compute == "serial") {

    replicate(reps, one_boot(1))

  } 
  #parallel
  else {

    cores <- max(1, detectCores() - 1)
    cl <- makeCluster(cores)

    clusterExport(cl,
      varlist = c("data","fun","n"),
      envir = environment()
    )

    clusterEvalQ(cl, {
      one_boot <- function(i){
        idx <- sample(seq_len(n), n, replace = TRUE)
        fun(data[idx, , drop = FALSE])
      }
    })

    out <- parSapply(cl, 1:reps, one_boot)

    stopCluster(cl)
    out
  }
}



#constructor
makeBootstrapCI <- function(fun, data, reps = 1000, level = 0.95,
                            compute = c("serial","parallel")) {

  compute <- match.arg(compute)

  boot_vals <- boot(fun, data, reps, compute)

  est <- mean(boot_vals)
  se <- sd(boot_vals)

  alpha <- 1 - level
  z <- qnorm(1 - alpha/2)

  lb <- est - z*se
  ub <- est + z*se

  new("bootstrapWaldCI",
      level = level,
      mean = est,
      sterr = se,
      lb = lb,
      ub = ub,
      data = data,
      reps = reps,
      fun = fun,
      compute = compute,
      boot_vals = boot_vals)
}


#show method
setMethod("show", "bootstrapWaldCI", function(object){
  cat(paste0("(", object@lb, ", ", object@ub, ")"), "\n")
})


#accessors
setGeneric("rebootstrap", function(object) standardGeneric("rebootstrap"))

setMethod("rebootstrap", "bootstrapWaldCI", function(object){

  boot_vals <- boot(object@fun, object@data, object@reps, object@compute)

  est <- mean(boot_vals)
  se <- sd(boot_vals)

  alpha <- 1 - object@level
  z <- qnorm(1 - alpha/2)

  object@mean <- est
  object@sterr <- se
  object@lb <- est - z*se
  object@ub <- est + z*se
  object@boot_vals <- boot_vals

  validObject(object)
  return(object)
})

```

### b)

```{r}
ci1 <- makeBootstrapCI(function(x) mean(x$y),
                       ggplot2::diamonds,
                       reps = 1000)

ci1
rebootstrap(ci1)

library(microbenchmark)

ci12 <- makeBootstrapCI(function(x) mean(x$y),
                       ggplot2::diamonds,
                       reps = 1000,
                       compute = "serial")

ci13 <- makeBootstrapCI(function(x) mean(x$y),
                       ggplot2::diamonds,
                       reps = 1000,
                       compute = "parallel")

microbenchmark(ci12)
microbenchmark(ci13)
```

$\texttt{parallel}$ method appears to be faster.

### c)

```{r}
dispCoef <- function(dat) {
  mod <- lm(mpg ~ cyl + disp + wt, data = dat)
  return(coef(mod)[["disp"]])
}

ci2 <- makeBootstrapCI(dispCoef,
                       mtcars,
                       reps = 1000)
ci2
rebootstrap(ci2)

ci22 <- makeBootstrapCI(dispCoef,
                       mtcars,
                       reps = 1000,
                       compute = "serial")

ci23 <- makeBootstrapCI(dispCoef,
                       mtcars,
                       reps = 1000,
                       compute = "parallel")

microbenchmark(ci22)
microbenchmark(ci23)
```

$\texttt{series}$ is the faster method here.

## Problem 3 - Large Data

### a)

```{r}

```







